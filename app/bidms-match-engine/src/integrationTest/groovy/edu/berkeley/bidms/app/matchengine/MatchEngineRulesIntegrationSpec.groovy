/*
 * Copyright (c) 2020, Regents of the University of California and
 * contributors.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package edu.berkeley.bidms.app.matchengine

import groovy.sql.Sql
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.boot.test.web.client.TestRestTemplate
import org.springframework.boot.test.web.server.LocalServerPort
import org.springframework.boot.web.client.RestTemplateBuilder
import org.springframework.http.HttpStatus
import org.springframework.http.ResponseEntity
import spock.lang.Specification

import javax.sql.DataSource

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class MatchEngineRulesIntegrationSpec extends Specification {

    @LocalServerPort
    int port

    @Autowired
    RestTemplateBuilder restTemplateBuilder

    @Autowired
    DataSource dataSource

    Sql sql
    TestRestTemplate restTemplate

    void setup() {
        this.sql = new Sql(dataSource)
        this.restTemplate = new TestRestTemplate(restTemplateBuilder)
        setupMatchView(sql)
        setupPartialMatch(sql)
    }

    void cleanup() {
        cleanupMatchView(sql)
        cleanupPartialMatch(sql)
        sql.close()
    }

    void setupMatchView(Sql sql) {
        sql.execute("""CREATE TABLE MatchView (
    uid             VARCHAR(64) NOT NULL,
  personNameType    VARCHAR(64),
  personNameSor     VARCHAR(64),
  personNameId      BIGINT,
  fullName          VARCHAR(255),
  givenName         VARCHAR(127),
  middleName        VARCHAR(127),
  surName           VARCHAR(127),
  dobSor            VARCHAR(64),
  dobId             BIGINT,
  birthDate         DATE,
  identifierType    VARCHAR(64) NOT NULL,
  identifierSor     VARCHAR(64),
  identifierId      BIGINT,
  identifier        VARCHAR(64) NOT NULL,
  idIsSorPrimaryKey BOOLEAN,
  phoneNumber       VARCHAR(64),
  emailAddress      VARCHAR(64)
)""" as String)
    }

    void cleanupMatchView(Sql sql) {
        sql.execute("DROP TABLE MatchView" as String)
    }

    void setupPartialMatch(Sql sql) {
        sql.execute("""CREATE TABLE SOR (
  sorId                smallint        GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  sorName              varchar(64)     NOT NULL
)""" as String)
        sql.execute("""CREATE TABLE SORObject (
  id                    bigint         GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  sorId                 smallint       NOT NULL REFERENCES SOR(sorId),
  sorObjKey             varchar(255)   NOT NULL,
  uid                   varchar(64),
  isDeleted             boolean        NOT NULL DEFAULT false
)""" as String)
        sql.execute("""CREATE TABLE PartialMatch (
  id                    bigint         GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  sorObjectId           bigint         NOT NULL REFERENCES SORObject(id),
  personUid             varchar(64)    NOT NULL,
  isReject              boolean        NOT NULL DEFAULT false
)""" as String)
    }

    void cleanupPartialMatch(Sql sql) {
        sql.execute("DROP TABLE PartialMatch" as String);
        sql.execute("DROP TABLE SORObject" as String);
        sql.execute("DROP TABLE SOR" as String);
    }

    def 'test that SOR and primary identifier gives an exact match'() {
        given:
        Map requestData = [
                systemOfRecord: 'PAYROLL',
                identifier    : '300000000'
        ]

        when: "a pre-existing entry with the SOR and primary identifier is created"
        sql.executeInsert(
                "INSERT INTO MatchView (uid, identifierType, identifierSor, identifier, idIsSorPrimaryKey) VALUES(?,?,?,?,?)" as String,
                "20000000", // uid
                "employeeId", // identifierType
                "PAYROLL", // identifierSor
                "300000000", // identifier
                true // idIsSorPrimaryKey
        )

        and: "request match search for same identifier"
        ResponseEntity<Map> response = restTemplate.postForEntity("http://localhost:${port}/match-engine/person" as String, requestData, Map)

        and: "cleanup"
        sql.executeUpdate("DELETE FROM MatchView WHERE uid=?" as String, "20000000")

        then:
        response.statusCode == HttpStatus.FOUND
        response.body.matchingRecord.referenceId == "20000000"
        response.body.matchingRecord.exactMatch
    }

    def "test that non-student SOR record with student ID gives an exact match"() {
        given:
        Map requestData = [
                systemOfRecord: "ALUMNI",
                identifier    : '5000000',
                dateOfBirth   : '1980-01-01',
                names         : [
                        [type: 'official', givenName: 'John', surName: 'Smith']
                ],
                identifiers   : [
                        [type: 'studentId', identifier: '10000000']
                ]
        ]

        when: "a pre-existing student from student SOR is created"
        sql.executeInsert(
                "INSERT INTO MatchView (uid, identifierType, identifierSor, identifier, idIsSorPrimaryKey, personNameType, personNameSor, givenName, surName) VALUES(?,?,?,?,?,?,?,?,?)" as String,
                "20000000", // uid
                "studentId", // identifierType
                "STUDENT", // identifierSor
                "10000000", // identifier
                true, // idIsSorPrimaryKey
                "studentName", // personNameType
                "STUDENT", // personNameSor
                "John", // givenName
                "Smith" // surName
        )

        and: "request match search for data from a non-student SOR with a student ID"
        ResponseEntity<Map> response = restTemplate.postForEntity("http://localhost:${port}/match-engine/person" as String, requestData, Map)

        and: "cleanup"
        sql.executeUpdate("DELETE FROM MatchView WHERE uid=?" as String, "20000000")

        then:
        response.statusCode == HttpStatus.OK
        with(response.body.matchingRecord) {
            referenceId == "20000000"
            exactMatch
            ruleNames.size() == 1 && ruleNames.first() == 'CANONICAL_FIRSTNAME_INITIAL_EXACT_LASTNAME_STUDENTID'
        }
    }

    def "test a possible match using first character of givenName and date of birth"() {
        given:
        Map requestData = [
                systemOfRecord: "STUDENT",
                identifier    : '5000000',
                dateOfBirth   : '1980-01-01',
                names         : [
                        [
                                type     : 'official',
                                givenName: 'Dave', // different than the existing name but first character is the same
                                surName  : 'Smith'
                        ]
                ],
                identifiers   : [
                        [type: 'studentId', identifier: '10000000']
                ]
        ]

        when:
        sql.executeInsert(
                "INSERT INTO MatchView (uid, identifierType, identifierSor, identifier, idIsSorPrimaryKey, personNameType, personNameSor, givenName, surName, dobSor, birthDate) VALUES(?,?,?,?,?,?,?,?,?,?,?)" as String,
                "20000000", // uid
                "employeeId", // identifierType
                "PAYROLL", // identifierSor
                "60000000", // identifier
                true, // idIsSorPrimaryKey
                "payrollName", // personNameType
                "PAYROLL", // personNameSor
                "David", // givenName
                "Smith", // surName
                "PAYROLL", // dobSor
                "1980-01-01" // birthDate
        )

        and:
        ResponseEntity<Map> response = restTemplate.postForEntity("http://localhost:${port}/match-engine/person" as String, requestData, Map)

        and: "cleanup"
        sql.executeUpdate("DELETE FROM MatchView WHERE uid=?" as String, "20000000")

        then:
        response.statusCode == HttpStatus.MULTIPLE_CHOICES
        (response.body.partialMatchingRecords as List).size() == 1
        with((response.body.partialMatchingRecords as List).first()) {
            referenceId == "20000000"
            !exactMatch
            ruleNames.size() == 1 && ruleNames.first() == 'POTENTIAL_FIRSTNAME_INITIAL_EXACT_LASTNAME_DOB'
        }
    }

    def "test rules which tests both superCanonical and fixedValue input attribute"() {
        // There's an existing uid from PAYROLL in the test data, so
        // this is a new incoming real time object for the same person that
        // should super match based on the employeeId.
        given:
        Map requestData = [
                systemOfRecord: "PAYROLL_SECONDARY",
                identifier    : '10000000',
                dateOfBirth   : '1980-01-01',
                names         : [
                        [type: 'official', givenName: 'John', surName: 'Smith']
                ],
                identifiers   : [
                        [type: 'employeeId', identifier: '10000000']
                ]
        ]

        when: "a pre-existing employee for primary payroll SOR is created"
        sql.executeInsert(
                "INSERT INTO MatchView (uid, identifierType, identifierSor, identifier, idIsSorPrimaryKey) VALUES(?,?,?,?,?)" as String,
                "20000000",
                "employeeId",
                "PAYROLL",
                "10000000",
                true
        )

        and: "request match search for data from a secondary payroll SOR"
        ResponseEntity<Map> response = restTemplate.postForEntity("http://localhost:${port}/match-engine/person" as String, requestData, Map)

        and: "cleanup"
        sql.executeUpdate("DELETE FROM MatchView WHERE uid=?" as String, "20000000")

        then:
        response.statusCode == HttpStatus.OK
        with(response.body.matchingRecord) {
            referenceId == "20000000"
            exactMatch
            ruleNames.size() == 1 && ruleNames.first() == 'SUPERCANONICAL_EMPLOYEE_ID'
        }
    }

    def "that that for a supercanonical, if the other SORObject is in PartialMatch, this SORObject also goes to PartialMatch"() {
        given:
        Map requestData = [
                systemOfRecord: "PAYROLL_SECONDARY",
                identifier    : '10000000',
                dateOfBirth   : '1980-01-01',
                names         : [
                        [type: 'official', givenName: 'John', surName: 'Smith']
                ],
                identifiers   : [
                        [type: 'employeeId', identifier: '10000000']
                ]
        ]

        when: "a PAYROLL object in PartialMatch"
        def sorId = sql.executeInsert("INSERT INTO SOR (sorName) VALUES(?)" as String, ["PAYROLL"])[0][0]
        def sorObjectId = sql.executeInsert("INSERT INTO SORObject(sorId, sorObjKey) VALUES(?,?)" as String, [sorId, "10000000"])[0][0]
        sql.executeInsert("INSERT INTO PartialMatch (sorObjectId, personUid) VALUES(?,?)" as String, [sorObjectId, "uid123"])

        and: "request match search for data from a secondary payroll SOR"
        ResponseEntity<Map> response = restTemplate.postForEntity("http://localhost:${port}/match-engine/person" as String, requestData, Map)

        and: "cleanup"
        sql.executeUpdate("DELETE FROM PartialMatch" as String)
        sql.executeUpdate("DELETE FROM SORObject" as String)
        sql.executeUpdate("DELETE FROM SOR" as String)

        then:
        response.statusCode == HttpStatus.MULTIPLE_CHOICES
        with(response.body.partialMatchingRecords[0]) {
            referenceId == "uid123"
            !exactMatch
            ruleNames.size() == 1 && ruleNames.first() == 'SUPERCANONICAL_EMPLOYEE_ID'
        }
    }

    def "test a possible match using exact surName and an email address"() {
        given:
        Map requestData = [
                systemOfRecord: "STUDENT",
                identifier    : '5000000',
                names         : [
                        [
                                type     : 'official',
                                givenName: 'David',
                                surName  : 'Smith'
                        ]
                ],
                emailAddresses: ['personal@email.com']
        ]

        when:
        sql.executeInsert(
                "INSERT INTO MatchView (uid, identifierType, identifierSor, identifier, idIsSorPrimaryKey, personNameType, personNameSor, givenName, surName, emailAddress) VALUES(?,?,?,?,?,?,?,?,?,?)" as String,
                "20000000", // uid
                "employeeId", // identifierType
                "PAYROLL", // identifierSor
                "60000000", // identifier
                true, // idIsSorPrimaryKey
                "payrollName", // personNameType
                "PAYROLL", // personNameSor
                "David", // givenName
                "Smith", // surName
                "personal@email.com" // emailAddress
        )

        and:
        ResponseEntity<Map> response = restTemplate.postForEntity("http://localhost:${port}/match-engine/person" as String, requestData, Map)

        and: "cleanup"
        sql.executeUpdate("DELETE FROM MatchView WHERE uid=?" as String, "20000000")

        then:
        response.statusCode == HttpStatus.MULTIPLE_CHOICES
        (response.body.partialMatchingRecords as List).size() == 1
        with((response.body.partialMatchingRecords as List).first()) {
            referenceId == "20000000"
            !exactMatch
            ruleNames.size() == 1 && ruleNames.first() == 'POTENTIAL_EXACT_LASTNAME_EMAIL'
        }
    }

    def "test no match found when email list is empty and no other info available other than name"() {
        given:
        Map requestData = [
                systemOfRecord: "STUDENT",
                identifier    : '5000000',
                names         : [
                        [
                                type     : 'official',
                                givenName: 'David',
                                surName  : 'Smith'
                        ]
                ],
                emailAddresses: []
        ]

        when:
        sql.executeInsert(
                "INSERT INTO MatchView (uid, identifierType, identifierSor, identifier, idIsSorPrimaryKey, personNameType, personNameSor, givenName, surName, emailAddress) VALUES(?,?,?,?,?,?,?,?,?,?)" as String,
                "20000000", // uid
                "employeeId", // identifierType
                "PAYROLL", // identifierSor
                "60000000", // identifier
                true, // idIsSorPrimaryKey
                "payrollName", // personNameType
                "PAYROLL", // personNameSor
                "David", // givenName
                "Smith", // surName
                "personal@email.com" // emailAddress
        )

        and:
        ResponseEntity<Map> response = restTemplate.postForEntity("http://localhost:${port}/match-engine/person" as String, requestData, Map)

        and: "cleanup"
        sql.executeUpdate("DELETE FROM MatchView WHERE uid=?" as String, "20000000")

        then:
        response.statusCode == HttpStatus.NOT_FOUND
    }

    def "test a possible match using exact surName and a phone number"() {
        given:
        Map requestData = [
                systemOfRecord: "STUDENT",
                identifier    : '5000000',
                names         : [
                        [
                                type     : 'official',
                                givenName: 'David',
                                surName  : 'Smith'
                        ]
                ],
                phoneNumbers  : ['+1 555-555-5555']
        ]

        when:
        sql.executeInsert(
                "INSERT INTO MatchView (uid, identifierType, identifierSor, identifier, idIsSorPrimaryKey, personNameType, personNameSor, givenName, surName, phoneNumber) VALUES(?,?,?,?,?,?,?,?,?,?)" as String,
                "20000000", // uid
                "employeeId", // identifierType
                "PAYROLL", // identifierSor
                "60000000", // identifier
                true, // idIsSorPrimaryKey
                "payrollName", // personNameType
                "PAYROLL", // personNameSor
                "David", // givenName
                "Smith", // surName
                "+1 555-555-5555" // phoneNumber
        )

        and:
        ResponseEntity<Map> response = restTemplate.postForEntity("http://localhost:${port}/match-engine/person" as String, requestData, Map)

        and: "cleanup"
        sql.executeUpdate("DELETE FROM MatchView WHERE uid=?" as String, "20000000")

        then:
        response.statusCode == HttpStatus.MULTIPLE_CHOICES
        (response.body.partialMatchingRecords as List).size() == 1
        with((response.body.partialMatchingRecords as List).first()) {
            referenceId == "20000000"
            !exactMatch
            ruleNames.size() == 1 && ruleNames.first() == 'POTENTIAL_EXACT_LASTNAME_PHONE'
        }
    }

    def "test no match found when phone number list is empty and no other info available other than name"() {
        given:
        Map requestData = [
                systemOfRecord: "STUDENT",
                identifier    : '5000000',
                names         : [
                        [
                                type     : 'official',
                                givenName: 'David',
                                surName  : 'Smith'
                        ]
                ],
                phoneNumbers  : []
        ]

        when:
        sql.executeInsert(
                "INSERT INTO MatchView (uid, identifierType, identifierSor, identifier, idIsSorPrimaryKey, personNameType, personNameSor, givenName, surName, phoneNumber) VALUES(?,?,?,?,?,?,?,?,?,?)" as String,
                "20000000", // uid
                "employeeId", // identifierType
                "PAYROLL", // identifierSor
                "60000000", // identifier
                true, // idIsSorPrimaryKey
                "payrollName", // personNameType
                "PAYROLL", // personNameSor
                "David", // givenName
                "Smith", // surName
                "+1 555-555-5555" // phoneNumber
        )

        and:
        ResponseEntity<Map> response = restTemplate.postForEntity("http://localhost:${port}/match-engine/person" as String, requestData, Map)

        and: "cleanup"
        sql.executeUpdate("DELETE FROM MatchView WHERE uid=?" as String, "20000000")

        then:
        response.statusCode == HttpStatus.NOT_FOUND
    }
}
